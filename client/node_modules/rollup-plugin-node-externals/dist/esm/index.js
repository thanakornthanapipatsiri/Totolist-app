import path, { dirname, isAbsolute, relative } from 'path';
import { builtinModules } from 'module';
import { promises } from 'fs';
import findUp from 'find-up';

/**
 * Determines if the `child` path is under the `parent` path.
 */
function isInDirectory(parent, child) {
    const relativePath = relative(parent, child);
    return !relativePath.startsWith('..') && !isAbsolute(relativePath);
}
/**
 * Iterates over package.json file paths recursively found in parent directories, starting from the
 * current working directory. If the current working directory is in a git repository, then package.json
 * files outside of the git repository will not be yielded.
 * @internal
 */
async function* findPackagePaths() {
    // Find git root if in git repository
    const gitDirectoryPath = await findUp('.git', { type: 'directory' });
    const gitRootPath = gitDirectoryPath === undefined
        ? undefined
        : dirname(gitDirectoryPath);
    function isInGitDirectory(path) {
        return gitRootPath === undefined || isInDirectory(gitRootPath, path);
    }
    let cwd = process.cwd();
    let packagePath;
    while ((packagePath = await findUp('package.json', { type: 'file', cwd })) &&
        isInGitDirectory(packagePath)) {
        yield packagePath;
        cwd = dirname(dirname(packagePath));
    }
}
/** @internal */
async function findDependencies({ packagePaths, keys, warnings }) {
    const dependencies = new Set();
    for await (const packagePath of packagePaths) {
        try {
            const pkg = JSON.parse((await promises.readFile(packagePath)).toString()) ?? {};
            // console.log(pkg)
            for (const key of keys) {
                const dependenciesToVersions = pkg[key] ?? {};
                for (const dependency of Object.keys(dependenciesToVersions)) {
                    dependencies.add(dependency);
                }
            }
        }
        catch {
            warnings.push(`Couldn't process '${packagePath}'. Make sure it is a valid JSON or use the 'packagePath' option`);
        }
    }
    return Array.from(dependencies);
}

/**
 * A Rollup plugin that automatically declares NodeJS built-in modules,
 * and optionally npm dependencies, as 'external'.
 */
function externals(options = {}) {
    // This will store all eventual warnings until we can display them.
    const warnings = [];
    // Consolidate options
    const config = {
        builtins: true,
        builtinsPrefix: 'strip',
        prefixedBuiltins: 'strip',
        packagePath: [],
        deps: true,
        devDeps: true,
        peerDeps: true,
        optDeps: true,
        include: [],
        exclude: [],
        ...options,
        _builtinsPrefix: 'strip', // Used to handle prefixes until v5
    };
    if ('builtinsPrefix' in options) {
        config._builtinsPrefix = options.builtinsPrefix;
    }
    else if ('prefixedBuiltins' in options) {
        warnings.push("The 'prefixedBuiltins' option is now deprecated, " +
            "please use 'builtinsPrefix' instead to silent this warning.");
        const { prefixedBuiltins } = options;
        config._builtinsPrefix =
            prefixedBuiltins === false
                ? 'ignore'
                : prefixedBuiltins === true || prefixedBuiltins === 'add'
                    ? 'add'
                    : 'strip';
    }
    // Map the include and exclude options to arrays of regexes.
    const [include, exclude] = ['include', 'exclude'].map(option => []
        .concat(config[option])
        .reduce((result, entry, index) => {
        if (entry instanceof RegExp)
            result.push(entry);
        else if (typeof entry === 'string')
            result.push(new RegExp('^' + entry.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$'));
        else if (entry) {
            warnings.push(`Ignoring wrong entry type #${index} in '${option}' option: ${JSON.stringify(entry)}`);
        }
        return result;
    }, []));
    // Support for builtin modules.
    const nodePrefix = 'node:';
    const nodePrefixRx = /^node:/;
    const _builtinModules = {
        bare: [],
        schemed: [],
        alwaysSchemed: [] // e.g., node:test in node 18+
    };
    builtinModules.forEach(builtin => {
        if (builtin.startsWith(nodePrefix)) {
            _builtinModules.schemed.push(builtin);
            _builtinModules.alwaysSchemed.push(builtin);
        }
        else {
            _builtinModules.bare.push(builtin);
            _builtinModules.schemed.push(nodePrefix + builtin);
        }
    });
    const builtins = new Set([
        ..._builtinModules.bare,
        ..._builtinModules.schemed
    ]);
    const alwaysSchemed = new Set(_builtinModules.alwaysSchemed);
    // A filter function to keep only non excluded dependencies.
    const isNotExcluded = (id) => !exclude.some(rx => rx.test(id));
    // The array of the final regexes.
    let externals = [];
    const isExternal = (id) => externals.some(rx => rx.test(id));
    return {
        name: 'node-externals',
        async buildStart() {
            // Begin with the include option as it has precedence over the other inclusion options.
            externals = [...include];
            // Add builtins
            if (config.builtins) {
                externals.push(new RegExp('^(?:' + _builtinModules.bare.filter(isNotExcluded).join('|') + ')$'), new RegExp('^node:(?:' + _builtinModules.schemed.filter(isNotExcluded).map(id => id.replace(nodePrefixRx, '')).join('|') + ')$'));
            }
            // Find and filter dependencies, supporting potential import from a sub directory (e.g. 'lodash/map').
            if (config.deps || config.devDeps || config.peerDeps || config.optDeps) {
                const packagePaths = [].concat(config.packagePath);
                const dependencies = (await findDependencies({
                    packagePaths: packagePaths.length > 0 ? packagePaths : findPackagePaths(),
                    keys: [
                        config.deps && 'dependencies',
                        config.devDeps && 'devDependencies',
                        config.peerDeps && 'peerDependencies',
                        config.optDeps && 'optionalDependencies'
                    ].filter(Boolean),
                    warnings
                })).filter(isNotExcluded);
                if (dependencies.length > 0) {
                    externals.push(new RegExp('^(?:' + dependencies.join('|') + ')(?:/.+)?$'));
                }
            }
            // Issue the warnings we may have collected.
            while (warnings.length > 0) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.warn(warnings.shift());
            }
        },
        resolveId(id) {
            // Ignore already resolved ids, relative imports and virtual modules.
            if (path.isAbsolute(id) || /^(?:\0|\.{1,2}[\\/])/.test(id))
                return null;
            // Check for externality.
            const external = isExternal(id) && isNotExcluded(id);
            // If not a builtin, or we're told not to handle prefixes, return status immediately.
            if (!builtins.has(id) || config._builtinsPrefix === 'ignore')
                return external ? false : null;
            // Otherwise, handle prefix.
            const stripped = id.replace(nodePrefixRx, '');
            return {
                id: alwaysSchemed.has(id) || config._builtinsPrefix === 'add'
                    ? 'node:' + stripped
                    : stripped,
                external
            };
        }
    };
}

export { externals as default, externals };
//# sourceMappingURL=index.js.map
